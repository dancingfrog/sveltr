<script>
    import {  createEventDispatcher } from 'svelte';

    export let title;
    export let color = '#ff3e00';
    export let extent = [[-1.0, -1.0], [1.0, 1.0]];
    export let groups = {};
    export let timeExtent = [];
    export let worldPosition = {
        x: 0.0,
        y: 0.0,
        z: 0.0,
        r: 1.0
    };

    let navContext;

    export let optionFlags = [];

    export let viewLocation, viewTarget;

    export const init = function () {
        console.log("Initializing Terrain Navigation");
        if (!!navContext !== true) {
            const canvas = document.getElementById("terrain-navigation-cursor");
            // window.canvas = canvas; // debug
            navContext = terrainNavigationCursor(canvas);
        }
    };

    let dispatch = createEventDispatcher();

    let formatPlayTime = (time) => "" + (new Date(time).toString());

    let positive_forward_vector_x = 0;
    let positive_forward_vector_z = 0;

    const navWidth = 200, navHeight = 200;

    let map = new Image();
    map.src = "images/map.png";
    map.style.width = navWidth + "px";
    map.style.height = navWidth + "px";

    let terrainWidth = extent[1][0] - extent[0][0],
        terrainDepth = extent[1][1] - extent [0][1];

    export let playTime = 1577810698673;

    let zoomY = 0;

    $: zoom(-zoomY);

    function renderTerrainNavigationCursor (ctx) {
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        const focusSize = width / (4 * worldPosition.r); // 256

        ctx.clearRect(0, 0, width, height);

        ctx.strokeRect(
                (width / 2 - focusSize / 2) + (width * worldPosition.x / terrainWidth),
                (height / 2 - focusSize / 2) + (height * worldPosition.z / terrainDepth),
                focusSize,
                focusSize)
    }

    function triggerMovement (direction) {
        // Get radius of viewing angle
        const distance = 0.5 / worldPosition.r;
        const vx = viewLocation[0] - viewTarget[0];
        const vz = viewLocation[2] - viewTarget[2];
        const r = Math.sqrt(Math.pow(vx, 2) + Math.pow(vz, 2));

        // console.log(vx, vz, r, distance);

        positive_forward_vector_x = (vx * (r - distance) / (r)) - vx;
        positive_forward_vector_z = (vz * (r - distance) / (r)) - vz;

        // console.log(positive_forward_vector_x, positive_forward_vector_z);

        // Adjust worldPosition coords
        switch (direction) {
            case "forward":
                worldPosition.x += positive_forward_vector_x;
                worldPosition.z += positive_forward_vector_z;
                break;
            case "backward":
                worldPosition.x -= positive_forward_vector_x;
                worldPosition.z -= positive_forward_vector_z;
                break;
            // // Need better math for lateral movement...
            // case "left":
            //     if (Math.abs(vx) > Math.abs(vz)) {
            //         worldPosition.x -= positive_forward_vector_z;
            //         worldPosition.z -= positive_forward_vector_x;
            //     } else {
            //         worldPosition.x += positive_forward_vector_z;
            //         worldPosition.z += positive_forward_vector_x;
            //     }
            //     break;
            // case "right":
            //     if (Math.abs(vx) > Math.abs(vz)) {
            //         worldPosition.x += positive_forward_vector_z;
            //         worldPosition.z += positive_forward_vector_x;
            //     } else {
            //         worldPosition.x -= positive_forward_vector_z;
            //         worldPosition.z -= positive_forward_vector_x;
            //     }
            //     break;
        }

        if (worldPosition.x < -terrainWidth * 0.45) worldPosition.x = -terrainWidth * 0.45;
        if (terrainWidth * 0.45 < worldPosition.x) worldPosition.x = terrainWidth * 0.45;
        if (worldPosition.z < -terrainDepth * 0.45) worldPosition.z = -terrainDepth * 0.45;
        if (terrainDepth * 0.45 < worldPosition.z) worldPosition.z = terrainDepth * 0.45;

        // Pass event to GLApp for view update
        dispatch("move");

        if (!!navContext === true) {
            renderTerrainNavigationCursor(navContext)
        }
    }

    function zoom (y) {
        worldPosition.y = y;
        worldPosition.r = Math.pow(2, (-y / 4));

        // Pass event to GLApp for view update
        dispatch("move");

        if (!!navContext === true) {
            renderTerrainNavigationCursor(navContext)
        }
    }

    function terrainNavigationCursor (canvas) {
        const ctx = canvas.getContext('2d');
        canvas.width = 1024;
        canvas.height = 1024;
        canvas.style.width = navWidth + "px";
        canvas.style.height = navWidth + "px";

        ctx.lineWidth = 8;
        ctx.strokeStyle = '#ff3e00';

        renderTerrainNavigationCursor(ctx);

        let mouse_x = 0, mouse_y = 0, mouse_down = false, mouse_disabled = false;

        const touchHit = function touchHit(event) {
            // console.log(event.touches);
            mouseHit(event.touches[0]);
        };

        const mouseHit = function mouseHit(event) {
            const scale_correct = 2.0;
            const current_x = event.clientX - (canvas.offsetParent.offsetLeft + canvas.offsetLeft);  // / parseInt(canvas.style.width.substring(-2,3))
            const current_y = event.clientY - (canvas.offsetParent.offsetTop + canvas.offsetTop); // / parseInt(canvas.style.height.substring(-2,3))
            if (!mouse_disabled) {
                const delta_x = (mouse_down) ? current_x - mouse_x : 0.0;
                const delta_y = (mouse_down) ? current_y - mouse_y : 0.0;
                // if (mouse_down) {
                //     console.log('mouse movement (', delta_x, ',', delta_y, ')');
                // }
                mouse_x = current_x;
                mouse_y = current_y;
                if (mouse_down) {
                    worldPosition.x += scale_correct * (terrainWidth / 2 * delta_x / parseInt(canvas.style.width.substring(-2,3)));
                    worldPosition.z += scale_correct * (terrainDepth / 2 * delta_y / parseInt(canvas.style.height.substring(-2,3)));

                    // Pass event to GLApp for view update
                    dispatch("move");

                    renderTerrainNavigationCursor(ctx);
                }
            }
        };

        if ('ontouchmove' in document.createElement('div'))  {
            canvas.addEventListener('touchstart', function(e){
                if (!mouse_disabled) {
                    // console.log('MouseDown');
                    touchHit(e);
                    mouse_down = true;
                }
                e.preventDefault();
            });
            canvas.addEventListener('touchmove', function(e){
                if (!mouse_disabled && mouse_down) {
                    touchHit(e);
                }
                e.preventDefault();
            });
            canvas.addEventListener('touchend', function(e){
                if (!mouse_disabled) {
                    // console.log('MouseUp');
                    mouse_down = false;
                }
                e.preventDefault();
            });
            console.log('touch is present');

        } else {
            canvas.addEventListener('mousedown', function(e) {
                if (!mouse_disabled) {
                    // console.log('MouseDown');
                    mouseHit(e);
                    mouse_down = true;
                }
                e.preventDefault();
            });
            canvas.addEventListener('mousemove', mouseHit);
            canvas.addEventListener('mouseup', function (e) {
                if (!mouse_disabled) {
                    // console.log('MouseUp');
                    mouse_down = false;
                }
                e.preventDefault();
            });
        }

        let sinceLastMovementEvent = 0;

        window.addEventListener('wheel', function (event) {
            const wheelEvent = (event || window['event']);

            if (((new Date()).getTime() - sinceLastMovementEvent) > 66) {

                sinceLastMovementEvent = (new Date()).getTime();

                if (wheelEvent.deltaY < 0) {
                    triggerMovement('forward');
                } else if (wheelEvent.deltaY > 0) {
                    triggerMovement('backward');
                }
            }

            wheelEvent.preventDefault();
        });

        window.addEventListener('keydown', function (event) {
            const kbEvent = (event || window['event']); // cross-browser shenanigans

            if (((new Date()).getTime() - sinceLastMovementEvent) > 66) {

                // console.log(kbEvent);

                sinceLastMovementEvent = (new Date()).getTime();

                if (kbEvent['keyCode'] === 32) { // spacebar

                    kbEvent.preventDefault();

                    return true;

                } else if (kbEvent['keyCode'] === 38 || kbEvent['keyCode'] === 87) { // up || W

                    triggerMovement('forward');

                    kbEvent.preventDefault();

                    return true;

                } else if (kbEvent['keyCode'] === 40 || kbEvent['keyCode'] === 83) { // down || S

                    triggerMovement('backward');

                    kbEvent.preventDefault();

                    return true;

                } else if (kbEvent['keyCode'] === 37 || kbEvent['keyCode'] === 65) { // left || A

                    triggerMovement('left');

                    kbEvent.preventDefault();

                    return true;

                } else if (kbEvent['keyCode'] === 39 || kbEvent['keyCode'] === 68) { // right || D

                    triggerMovement('right');

                    kbEvent.preventDefault();

                    return true;

                } else {
                    console.log('Keyboard Event: ', kbEvent['keyCode']);

                    return false;
                }
            }
        });

        document.getElementById("magnification").addEventListener('keydown', function (event) {
            const kbEvent = (event || window['event']); // cross-browser shenanigans

            kbEvent.preventDefault();

            return true;
        });

        return ctx;
    }
</script>

<style>
    .controls {
        float: right;
        color: #282c34;
        position: relative;
        margin: 8px;
        margin-top: -50%;
        width: 300px;
        /*height: 128px;*/
        padding: 1em;
        background-color: rgba(255,255,255,0.7);
        border-radius: 2px;
        z-index: 2;
    }

    @media screen and (max-width: 480px) {
        .controls {
            margin-top: 8px;
        }
    }

    .controls label input[type="color"] {
        clear: both;
        margin: 100px;
        margin-top: 2px;
        margin-bottom: 10px;
    }

    #terrain-navigation-view {
        padding: 2px;
    }

    #terrain-navigation-cursor {
        position: absolute;
        top: 0px;
        left: 0px;
        margin-top: 16px;
        margin-left: 64px;
        min-width: 20px;
        min-height: 20px;
        border: 2px solid;
    }
</style>

<div class="controls">
    <div id="terrain-navigation-view">
        <img src={map.src}
             width={map.style.width}
             height={map.style.height} />
        <canvas id="terrain-navigation-cursor"
                width="{map.width}"
                height="{map.height}"
                style="border-color: {color}"
        ></canvas>
    </div>

    <h4>{ title } Navigation</h4>

<!--    <h6>{worldPosition.x}, {worldPosition.y}, {worldPosition.z}</h6>-->

    <label>
        <b>-</b><input id="magnification" type="range" bind:value={zoomY} on:input={zoomY} min={-8} max={1} step={0.1}><b>+</b><br />
        Maginfication
    </label><br />

    <label>
        <input type="checkbox" bind:checked={groups[0]} /> Group 1
    </label><br />

    <label>
        <input type="checkbox" bind:checked={groups[1]} /> Group 2
    </label><br />

    <label>
        <input type="checkbox" bind:checked={groups[2]} /> Group 3
    </label><br />

    <label>
        <input type="checkbox" bind:checked={groups[3]} /> Group 4
    </label><br />

    <label>
        <input type="checkbox" bind:checked={groups[4]} /> Group 5
    </label><br />

    <label>
        <input type="checkbox" bind:checked={groups[5]} /> Group 6
    </label><br />

    {#if (optionFlags['labels'].length > 0 && optionFlags['values'].length > 0)}
        {#each optionFlags['values'] as option, o}
        <label>
            <input type="checkbox" bind:checked={option} /> {optionFlags['labels'][o]}
        </label><br />
        {/each}
    {/if}

    {#if timeExtent.length == 2}
    <label>
        <input id="time" type="range" bind:value={playTime} on:input={playTime} min={timeExtent[0]} max={timeExtent[1]} step={10}><br />
        {formatPlayTime(playTime)}
    </label><br />
    {/if}

</div>
