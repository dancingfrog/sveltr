---
title: README
author: 'John Hall'
date: '2021-02-14'
draft: false
categories:
  - Covid
  - Covid-19
  - Death
  - Mortality
  - R
tags:
  - R Markdown
always_allow_html: true
output:
  html_document:
    keep_md: yes
params:
  target_html: TRUE
---
# Develop a data visualization application

  _"We are trying to get a sense of your ability to turn data into a functional web application. We would rather see something cool than have you just follow the instructions."_

### Approach

The first step in developing this data-oriented application is to understand the information that this data is intended to convey. The title of the dataset gives some indication of its content. My overall sense of what kinds of experiences can be meaningfully facilitated by the information contained therein can be greatly enhanced by 1) A description of each field, 2) Knowledge of how the data was gathered and maintained, and 3) Some exploratory operations (statistical aggregation, plotting, mapping, etc.) on the dataset elements/features.

  1. A description of the fields was provided. Among these, the `database` field is described as naming the source of the given record in the dataset, which will help with step **2**. The fields labeled `geoid_co` and `geoid_st` respectively contain county and state level FIPS identifiers, which is useful for sorting and grouping the data by county/state while in its tabular form (i.e. pre-visualization filters). `the_geom` field contains geometry in a binary format, which can be transformed into GeoJSON or WKT. To minimize the size of the query response, I removed both `the_geom` and `the_geom_webmercator` from the Carto SQL request and replaced them with `ST_AsText(the_geom_webmercator) as geom`, for subsequent geospatial processing.

  2. Values in the `database` field include [Underlying Cause of Death 1999-2018 - CDC Wonder](https://wonder.cdc.gov/wonder/help/ucd.html), a website maintained by the CDC which describes itself as " -level national mortality and population data," captured from death certificates. For reference, I downloaded the complete technical instructions that correspond to this dataset (_Note_: the documentation available online is for the more recent "1999 - 2019" dataset). By comparing the descriptions of the fields in the given dataset to the documentation for "Underlying Cause of Death 1999-2019", I can see that there are additional fields that have been joined to the original "Underlying Cause of Death 1999-2018" dataset in some unknown way, but presumably keyed on the location (by county FIPS) that each record represents. The values found in the cause of death field (`death_cause`) do **not** correspond to the (Cause of Death (ICD-10))[https://wonder.cdc.gov/wonder/help/ucd.html#ICD-10%20Codes] codes listed in the technical documentation, indicating that this dataset has already been transformed in some non-trivial way as compared to one of its source (i.e., "Underlying Cause of Death 1999-2018") and the concept of "Deaths of Despair" seems to come from another source entirely, along with any informatin relating to Covid-19.

  3. R was used to read in the JSON data from Rural Innovation's Carto platform and save it to local disk:

```{r setup, cache = FALSE, echo = FALSE, include=FALSE}
options(warn = -1)
working_dir <- getwd()
print(working_dir)
print(grepl("/content", getwd(), ignore.case = TRUE))
if (grepl("/content", getwd(), ignore.case = TRUE)) {
  working_dir <- stringr::str_replace(getwd(), "/content", "")
  setwd(working_dir)
  print("")
}
if (!require("knitr")) {
  install.packages("knitr")
  library("knitr")
}
knitr::opts_chunk$set(cache = TRUE)
knitr::opts_chunk$set(echo = TRUE)
```


```{r get_data, cache = FALSE, echo = TRUE}
data_file <- paste0(working_dir, "/content/data/dod_covid_county.RData")
if (!file.exists(data_file)) {
  dod_covid_county_data <- data.frame(jsonlite::fromJSON("https://ruralinnovation-admin.carto.com/api/v2/sql?q=select%20cartodb_id,fid,geoid_co,name,namelsad,st_stusps,geoid_st,st_name,land_sqmi,water_sqmi,lon,lat,acp_name,cbsa_type,rin_flag,database,geo_level,geoid_cbsa,geoid_acp,co_name,cbsa_name,cdc_urbanization,time_interval,time_period,death_cause,age_group,gender,race,population,deaths_dod,age_adjusted_rate,age_adjusted_rate_se,age_adjusted_rate_lower_95_ci,age_adjusted_rate_upper_95_ci,crude_rate,crude_rate_se,crude_rate_lower_95_ci,crude_rate_upper_95_ci,acp_image,pop,confirmed,deaths_covid,confirmed_per_100k,deaths_per_100k,ST_AsText(the_geom_webmercator)%20as%20geom%20from%20%22ruralinnovation-admin%22.dod_covid_county", flatten = TRUE)$rows)
   save(dod_covid_county_data, file = data_file)
}

dataset <- load(data_file) # will import a data.frame called "dod_covid_county_data" from data_file
dod_covid_county_data <- dod_covid_county_data[order(data.frame(list(dod_covid_county_data$geoid_co))), ] # Order by County FIPS
str(dod_covid_county_data)

```
Having read portions of the "Underlying Cause of Death 1999-2019" technical documentation and looking at the data itself, I can see that there are multiple records associated with each place (county), so it would be good to filter records by an additional characteristic, in this case, Cause of Death (`death_cause`), before beginning to look deeper at each "bucket" of data that is produced.

```{r death_cause, cache = FALSE, echo = FALSE}
library(DT)
library(dplyr)
library(magrittr)

#causes <- dod_covid_county_data %>% dplyr::select(death_cause) %>% dplyr::distinct()
causes <- data.frame(list(dod_covid_county_data$death_cause)) %>% dplyr::distinct()
causes <- causes[order(causes),] # Order by alpha

showTablePreivew <- function(x) {
    data_preview <- x[c(1:5), !(names(dod_covid_county_data) %in% c("geom"))] # Exclude geometry
    if (exists("params")) {
        if (params$target_html)
          DT::datatable(data_preview,
                        #extensions = 'Buttons',
                        #options = list(dom = 'rtBip', buttons = c('csv', 'excel', 'pdf'), lengthMenu = list(c(10, 10, 10, -1), c(50, 50, 100, "All")))
          )
        else knitr::kable(data_preview)

    } else {
        head(data_preview) # View(data_preview)
    }
}

```

The five recorded causes of death included in this data are:

```{r, cache = FALSE, echo = FALSE, results = 'asis'}
print(causes)
```

The data corresponding to each of these causes is filter into its own object/table using R (comments include Carto SQL queries to do the same).

```{r, cache = FALSE, echo = TRUE}
death_by_alcohol_data <- dod_covid_county_data[grepl("Alcohol", dod_covid_county_data[, 25]), ] #dod_covid_county_data %>% dplyr::filter(death_cause = "Alcohol")
#data.frame(jsonlite::fromJSON("https://ruralinnovation-admin.carto.com/api/v2/sql?q=select%20cartodb_id,fid,geoid_co,name,namelsad,st_stusps,geoid_st,st_name,land_sqmi,water_sqmi,lon,lat,acp_name,cbsa_type,rin_flag,database,geo_level,geoid_cbsa,geoid_acp,co_name,cbsa_name,cdc_urbanization,time_interval,time_period,death_cause,age_group,gender,race,population,deaths_dod,age_adjusted_rate,age_adjusted_rate_se,age_adjusted_rate_lower_95_ci,age_adjusted_rate_upper_95_ci,crude_rate,crude_rate_se,crude_rate_lower_95_ci,crude_rate_upper_95_ci,acp_image,pop,confirmed,deaths_covid,confirmed_per_100k,deaths_per_100k,ST_AsText(the_geom_webmercator)%20as%20geom%20from%20%22ruralinnovation-admin%22.dod_covid_county%20where%20death_cause%20ilike%20%27Alcohol%27", flatten = TRUE)$rows)
death_by_alcohol_data %>% showTablePreivew
```


```{r, cache = FALSE, echo = TRUE}
death_by_cirrhosis_data <- dod_covid_county_data[grepl("Cirrhosis", dod_covid_county_data[, 25]), ] #dod_covid_county_data %>% dplyr::filter(death_cause = "Cirrhosis")
#data.frame(jsonlite::fromJSON("https://ruralinnovation-admin.carto.com/api/v2/sql?q=select%20cartodb_id,fid,geoid_co,name,namelsad,st_stusps,geoid_st,st_name,land_sqmi,water_sqmi,lon,lat,acp_name,cbsa_type,rin_flag,database,geo_level,geoid_cbsa,geoid_acp,co_name,cbsa_name,cdc_urbanization,time_interval,time_period,death_cause,age_group,gender,race,population,deaths_dod,age_adjusted_rate,age_adjusted_rate_se,age_adjusted_rate_lower_95_ci,age_adjusted_rate_upper_95_ci,crude_rate,crude_rate_se,crude_rate_lower_95_ci,crude_rate_upper_95_ci,acp_image,pop,confirmed,deaths_covid,confirmed_per_100k,deaths_per_100k,ST_AsText(the_geom_webmercator)%20as%20geom%20from%20%22ruralinnovation-admin%22.dod_covid_county%20where%20death_cause%20ilike%20%27Cirrhosis%27", flatten = TRUE)$rows)
death_by_cirrhosis_data %>% showTablePreivew
```


```{r, cache = FALSE, echo = TRUE}
death_by_dod_data <- dod_covid_county_data[grepl("DoD", dod_covid_county_data[, 25]), ] #dod_covid_county_data %>% dplyr::filter(death_cause = "DoD" )
#data.frame(jsonlite::fromJSON("https://ruralinnovation-admin.carto.com/api/v2/sql?q=select%20cartodb_id,fid,geoid_co,name,namelsad,st_stusps,geoid_st,st_name,land_sqmi,water_sqmi,lon,lat,acp_name,cbsa_type,rin_flag,database,geo_level,geoid_cbsa,geoid_acp,co_name,cbsa_name,cdc_urbanization,time_interval,time_period,death_cause,age_group,gender,race,population,deaths_dod,age_adjusted_rate,age_adjusted_rate_se,age_adjusted_rate_lower_95_ci,age_adjusted_rate_upper_95_ci,crude_rate,crude_rate_se,crude_rate_lower_95_ci,crude_rate_upper_95_ci,acp_image,pop,confirmed,deaths_covid,confirmed_per_100k,deaths_per_100k,ST_AsText(the_geom_webmercator)%20as%20geom%20from%20%22ruralinnovation-admin%22.dod_covid_county%20where%20death_cause%20ilike%20%27DoD%27", flatten = TRUE)$rows)
death_by_dod_data %>% showTablePreivew
```


```{r, cache = FALSE, echo = TRUE}
death_by_drug_data <- dod_covid_county_data[grepl("Drug", dod_covid_county_data[, 25]), ] #dod_covid_county_data %>% dplyr::filter(death_cause = "Drug")
#data.frame(jsonlite::fromJSON("https://ruralinnovation-admin.carto.com/api/v2/sql?q=select%20cartodb_id,fid,geoid_co,name,namelsad,st_stusps,geoid_st,st_name,land_sqmi,water_sqmi,lon,lat,acp_name,cbsa_type,rin_flag,database,geo_level,geoid_cbsa,geoid_acp,co_name,cbsa_name,cdc_urbanization,time_interval,time_period,death_cause,age_group,gender,race,population,deaths_dod,age_adjusted_rate,age_adjusted_rate_se,age_adjusted_rate_lower_95_ci,age_adjusted_rate_upper_95_ci,crude_rate,crude_rate_se,crude_rate_lower_95_ci,crude_rate_upper_95_ci,acp_image,pop,confirmed,deaths_covid,confirmed_per_100k,deaths_per_100k,ST_AsText(the_geom_webmercator)%20as%20geom%20from%20%22ruralinnovation-admin%22.dod_covid_county%20where%20death_cause%20ilike%20%27Drug%27", flatten = TRUE)$rows)
death_by_drug_data %>% showTablePreivew
```


```{r, cache = FALSE, echo = TRUE}
death_by_suicide_data <- dod_covid_county_data[grepl("Suicide", dod_covid_county_data[, 25]), ] #dod_covid_county_data %>% dplyr::filter(death_cause = "Suicide")
#data.frame(jsonlite::fromJSON("https://ruralinnovation-admin.carto.com/api/v2/sql?q=select%20cartodb_id,fid,geoid_co,name,namelsad,st_stusps,geoid_st,st_name,land_sqmi,water_sqmi,lon,lat,acp_name,cbsa_type,rin_flag,database,geo_level,geoid_cbsa,geoid_acp,co_name,cbsa_name,cdc_urbanization,time_interval,time_period,death_cause,age_group,gender,race,population,deaths_dod,age_adjusted_rate,age_adjusted_rate_se,age_adjusted_rate_lower_95_ci,age_adjusted_rate_upper_95_ci,crude_rate,crude_rate_se,crude_rate_lower_95_ci,crude_rate_upper_95_ci,acp_image,pop,confirmed,deaths_covid,confirmed_per_100k,deaths_per_100k,ST_AsText(the_geom_webmercator)%20as%20geom%20from%20%22ruralinnovation-admin%22.dod_covid_county%20where%20death_cause%20ilike%20%27Suicide%27", flatten = TRUE)$rows)
death_by_suicide_data %>% showTablePreivew
```

#### Potential Uses

At this point, I believe that this dataset allows one to explore potential correlations between historic mortality factors/rates and the total number of deaths due to Covid-19 (in 2020), and to "drill down" on those relationships within a given location (county or metropolitan area). As I mentioned early, I can get a "feel" for ways to position the data by looking at some basic summary statistics and quick visualizations for a given bucket (i.e. "Suicide" in the examples below).

```{r population_vs_suicide_rate, cache = FALSE, echo = FALSE}
library(ggplot2)

time_period1999_2003 <- grepl("1999-2003", dod_covid_county_data[, 24])
time_period2004_2008 <- grepl("2004-2008", dod_covid_county_data[, 24])
time_period2009_2013 <- grepl("2009-2013", dod_covid_county_data[, 24])
time_period2014_2018 <- grepl("2014-2018", dod_covid_county_data[, 24])

# 1999 - 2003 crude death rates by suicide
suicide_rates_1999_2003 <- na.exclude(death_by_suicide_data[time_period1999_2003, ])$crude_rate
print(paste0(length(suicide_rates_1999_2003), " county suicide rate records for 1999-2003 (death_cause = 'Suicide'): "))
print(summary(suicide_rates_1999_2003))

# Compare 1999- 2003 'population' summary ...
pop1999_2003 <- na.exclude(death_by_suicide_data[time_period1999_2003, ])$population / 5
print(paste0(length(pop1999_2003), " county 'population' records for 1999-2003 (death_cause = 'Suicide'): "))
print(summary(pop1999_2003))
# ... to 2019 'pop' summary
print("county 'pop' summary for 2019 :")
print(summary(na.exclude(death_by_suicide_data[time_period1999_2003, ])$pop))

# 2004 - 2008 crude death rates by suicide
suicide_rates_2004_2008 <- na.exclude(death_by_suicide_data[time_period2004_2008, ])$crude_rate
print(paste0(length(suicide_rates_2004_2008), " county suicide rate records for 2004-2008 (death_cause = 'Suicide'): "))
print(summary(suicide_rates_2004_2008))

# Compare 2004 - 2008 'population' summary ...
pop2004_2008 <- na.exclude(death_by_suicide_data[time_period2004_2008, ])$population / 5
print(paste0(length(pop2004_2008), " county 'population' records for 2004-2008 (death_cause = 'Suicide'): "))
print(summary(pop2004_2008))
# ... to 2019 'pop' summary
print("county 'pop' summary for 2019 :")
print(summary(na.exclude(death_by_suicide_data[time_period2004_2008, ])$pop))

# 2009 - 2013 crude death rates by suicide
suicide_rates_2009_2013 <- na.exclude(death_by_suicide_data[time_period2009_2013, ])$crude_rate
print(paste0(length(suicide_rates_2009_2013), " county suicide rate records for 2009-2013 (death_cause = 'Suicide'): "))
print(summary(suicide_rates_2009_2013))

# Compare 2009 - 2013 'population' summary ...
pop2009_2013 <- na.exclude(death_by_suicide_data[time_period2009_2013, ])$population / 5
print(paste0(length(pop2009_2013), " county 'population' records for 2009-2013 (death_cause = 'Suicide'): "))
print(summary(pop2009_2013))
# ... to 2019 'pop' summary
print("county 'pop' summary for 2019 :")
print(summary(na.exclude(death_by_suicide_data[time_period2009_2013, ])$pop))

# 2014 - 2018 crude death rates by suicide
suicide_rates_2014_2018 <- na.exclude(death_by_suicide_data[time_period2014_2018, ])$crude_rate
print(paste0(length(suicide_rates_2014_2018), " county suicide rate records for 2014-2018 (death_cause = 'Suicide'): "))
print(summary(suicide_rates_2014_2018))

# Compare 2014-2018 'population' summary ...
pop2014_2018 <- na.exclude(death_by_suicide_data[time_period2014_2018, ])$population / 5
print(paste0(length(pop2014_2018), " county 'population' records for 2014-2018 (death_cause = 'Suicide'): "))
print(summary(pop2014_2018))
# ... to 2019 'pop' summary
print("county 'pop' summary for 2019 :")
print(summary(na.exclude(death_by_suicide_data[time_period2014_2018, ])$pop))

```

_For each county record the `population` value appears to be the sum of 5 years worth of population estimates, as compared to the single year (2019) estimate stored in `pop`._

```{r covid_deaths_vs_suicide_rate, cache = FALSE, echo = FALSE}

plot_population_vs_suicide_rate <- function(population, suicide_rate, covid_death_rate, years){
    options(repr.plot.width=4, repr.plot.height=3.5) # Set the initial plot area dimensions
    df <- data.frame(population, suicide_rate, covid_death_rate)
    df <- df[order(df$population), ]
    p <- ggplot(df, aes(x = suicide_rate, y = covid_death_rate)) +
            geom_point(stroke = 1, shape = 23, aes(size = population, fill = suicide_rate), alpha = 0.5) +
            scale_fill_gradient(low = "#56B4E9", high = "#E69F00") +
            ggtitle(paste0("Covid Death Rate (2019) vs. Historic Suicide Rate (", years, ") per 100k ppl"))
    print(p)
}

plot_population_vs_suicide_rate(pop1999_2003, suicide_rates_1999_2003, na.exclude(death_by_suicide_data[time_period1999_2003, ])$deaths_per_100k, "1999 - 2003")
plot_population_vs_suicide_rate(pop2004_2008, suicide_rates_2004_2008, na.exclude(death_by_suicide_data[time_period2004_2008, ])$deaths_per_100k, "2004 - 2008")
plot_population_vs_suicide_rate(pop2009_2013, suicide_rates_2009_2013, na.exclude(death_by_suicide_data[time_period2009_2013, ])$deaths_per_100k, "2009 - 2013")
plot_population_vs_suicide_rate(pop2014_2018, suicide_rates_2014_2018, na.exclude(death_by_suicide_data[time_period2014_2018, ])$deaths_per_100k, "2014 - 2018")
```



### Preperation for Web/Visualization

I want to make use of the extensive search, filter and aggregation capabilities of Elasticsearch and although ES can also index features/records by geospatial coordinates, it's tesselation processor was having a hard time with this particular dataset because some geometry values produce this error:

    {
      "error": {
        "root_cause": [
          {
            "type": "mapper_parsing_exception",
            "reason": "failed to parse field [geom] of type [geo_shape]"
          }
        ],
        "type": "mapper_parsing_exception",
        "reason": "failed to parse field [geom] of type [geo_shape]",
        "caused_by": {
          "type": "illegal_argument_exception",
          "reason": "Unable to Tessellate shape


 Although PostgeSQL (and PostGIS) are familiar and typical data stores for geospatial data, .

```{r geojson, cache = FALSE, echo = FALSE}
if (!require(geojsonio)) {
    install.packages(c("binaryLogic"))
    devtools::install_github("jeroen/V8", upgrade = FALSE)
    devtools::install_github("ropensci/jqr", upgrade = FALSE)
    devtools::install_github("ropensci/geojson", upgrade = FALSE)
    devtools::install_github("ropensci/geojsonio", upgrade = FALSE)
}
library(geojson)
library(geojsonio)

```

```{r elasticsearch, cache = FALSE, echo = FALSE}
if (!require(elasticsearchr)) {
    devtools::install_github("alexioannides/elasticsearchr", upgrade = FALSE)
    library(elasticsearchr)
}

# Setup Elasticsearch index with the following minimal mapping:

#PUT _ingest/pipeline/geom_pipeline
#{
#  "description" : "Process geometry from escaped GeoJSON",
#  "processors" : [
#    {
#      "json" : {
#        "field" : "geom",
#        "target_field" : "geom"
#      }
#    }
#  ]
#}

#PUT dod_covid_county
#{
#  "settings": {
#    "default_pipeline": "geom_pipeline",
#    "number_of_shards": 1
#  },
#  "properties": {
#    "geom": {
#      "type": "geo_shape"
#    }
#  }
#}


# Try index
(y <- multipolygon(dod_covid_county_data[c(1), ]$geom))
geo_type(y)
geo_pretty(y)
geo_write(y, f <- tempfile(fileext = ".geojson"))
geom <- jsonlite::fromJSON(f, FALSE)
geom_frame <- data.frame(geometry = jsonlite::fromJSON(f, FALSE))
geometry_frame <- dplyr::bind_cols(dod_covid_county_data[1, ], geom_frame)
elastic("http://localhost:9200", "dod_covid_county", "_doc")  %index% geometry_frame

hits <- data.frame()
try({
    hits <- elasticsearchr::elastic("http://localhost:9200", "dod_covid_county") %search% query('{
      "match_all": {}
    }')
})
total <-  1 #length(dod_covid_county_data[,1])

if (dim(hits) == c(0, 0) || is.na(hits) || length(hits[,1]) < total) { # check length of hit is > 62840
    for (i in c(1:total)) {
        # Easiest to index 1 record at a time... might take a while
        elastic("http://localhost:9200", "dod_covid_county", "_doc")  %index% dod_covid_county_data[c(i), ]
    }
}


```



# Scenarios

### 2.1 CORI Website map

### 2.2 Broadband explorer
